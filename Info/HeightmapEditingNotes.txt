Diamond shaped
Google: hollow diamond astrisk in c++
http://www.cplusplus.com/forum/beginner/89922/
http://stackoverflow.com/questions/19734399/printing-out-patterns-with-asterisks


X,Z Point

(0,0) (1,0) (2,0) (3,0) (4,0) (5,0) (6,0) (7,0)
(0,1) (1,1) (2,1) (3,1) (4,1) (5,1) (6,1) (7,1)
(0,2) (1,2) (2,2) (3,2) (4,2) (5,2) (6,2) (7,2)
(0,3) (1,3) (2,3) (3,3) (4,3) (5,3) (6,3) (7,3)
(0,4) (1,4) (2,4) (3,4) (4,4) (5,4) (6,4) (7,4)
(0,5) (1,5) (2,5) (3,5) (4,5) (5,5) (6,5) (7,5)
(0,6) (1,6) (2,6) (3,6) (4,6) (5,6) (6,6) (7,6)
(0,7) (1,7) (2,7) (3,7) (4,7) (5,7) (6,7) (7,7)


From a point x,z from the mouse projected into 3D space
extend a radius to form a circle on the terrain
locate the points located within that circle on the heightmap
slowly increment the height of each point located inside this circle.
Each point will increase at a smaller speed of the point that is closest to the mouse pos.

Brush = x,z + radius of circle

Radius division will will begin with radius of 10 and go up to 50 or 100 depending on size of landscape.
From the brush radius need to have a Speed radius that starts a 1 and each point outside of this speed radius will
have a smaller speed of the prev layer

If a point is not on the map then it will get omitted and the algorithm will just continue

So if the mouse 3D point is at (3,3) with Brush radius of 10, we fan out beginning with Speed radius of 1
until we reach 0 from the brush radius.
locations for all the heightmap points contained inside this part of the circle at the first level.
Points:

      (3,2)
(2,3) (3,3) (4,3)
      (3,4)

The next level will involve the points 

            (3,1)
      (2,2)       (4,2)
(1,3)                   (5,3)
      (2,4)       (4,4)
            (3,5)

...

Will fan out from a fanning variable of 10 and subtract at each layer until we reach 0


define mask3x3[3][3]=
{
  0, 1, 0
  1, 0, 1
  0, 1, 0
}

define mask5x5[5][5]=
{
  0, 0, 1, 0, 0
  0, 1, 0, 1, 0
  1, 0, 0, 0, 1
  0, 1, 0, 1, 0
  0, 0, 1, 0, 0
}


0 0 0 1 0 0 0
0 0 1 0 1 0 0
0 1 0 0 0 1 0
1 0 0 0 0 0 1
0 1 0 0 0 1 0
0 0 1 0 1 0 0
0 0 0 1 0 0 0


brushRadius = 10
mouse3DPos = (3,3) //Need to find the aproximate point in the heightmap to this point

HeightmapBuildFanningPoints(brushRadius, mouse3DPos)
  size = 3
  for each fanning layer from i=0 to i<brushRadius
    buildFanningPoints(size, brushRadius, mouse3DPos))
    size += 2;
  end
end

buildFanningPoints(int& size, brushRadius, mouse3DPos)
  width = size
  depth = size
  //if (i=brushRadius)
  //  size = 5
  //else
  //  size = size * 2 // size has increased
  //end
  //points.size = size;
  //for j=0; j<size
  //for z=0; z<depth
    //for x=0; x<width
      if (i==brushRadius)
        points[i] = mouse3DPos
      else
      Point p1(mouse3DPos.x+1, 0, mouse3DPos.z)
      Point p2
    //end
  //end
  
  r = 5
  m = floor(r / 2) // = 2
  
  r = 3
  m = floor(r / 2) // = 1
  
  bool halffound=false
  
  for (int z=0; z<depth; z++)
  {
    for (int x=0; x<width; x++)
    {
      if x==0
      {
        
      }
    }
  }
  
  fanningPointSet.add(points)
  
end

RaiseHeightmap()
  speed = 10
  for each fanning point set i
    raise(speed, fanningPointSet[i])
    speed -= 0.05;
  end
end

raise(speed, fanningPoint)
  x = fanningPoint.x
  z = fanningPoint.z
  heightmap[x][z] += speed;
end

lower(speed, fanningPoint)
  x = fanningPoint.x
  z = fanningPoint.z
  heightmap[x][z] -= speed;
end